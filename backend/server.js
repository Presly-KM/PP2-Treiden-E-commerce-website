const express = require('express');                                         // On commence la partie backend par l'installation et l'import d'express. Ce fichier(server.js) sera notre entrée à l'application express.
const cors = require('cors');
const dotenv = require('dotenv');                                           // dotenv est une librairie qui nous permet de charger les variables d'environnement à partir d'un fichier .env. On va l'utiliser pour stocker les informations sensibles comme les clés API, les mots de passe, etc. On va créer un fichier .env à la racine de notre projet et y ajouter nos variables d'environnement. Par exemple, on peut ajouter PORT=9000 pour définir le port sur lequel notre serveur va écouter les requêtes.
const connectDB = require('./config/db');                                  // On importe la fonction connectDB depuis le fichier config/db.js. Ce fichier va contenir la logique de connexion à la base de données MongoDB. On va l'utiliser pour se connecter à la base de données avant de démarrer le serveur. On va créer ce fichier juste après avoir installé mongoose.
const userRoutes = require('./routes/userRoutes');                        // On importe les routes des utilisateurs depuis le fichier routes/userRoutes.js. Ce fichier va contenir les routes pour l'inscription et la connexion des utilisateurs. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "userRoutes.js". Dans ce fichier, on va définir les routes pour l'inscription et la connexion des utilisateurs. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const productRoutes = require('./routes/productRoutes'); // On importe les routes des produits depuis le fichier routes/productRoutes.js. Ce fichier va contenir les routes pour la création, la mise à jour, la suppression et la récupération des produits. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "productRoutes.js". Dans ce fichier, on va définir les routes pour la création, la mise à jour, la suppression et la récupération des produits. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const cartRoutes = require('./routes/cartRoutes'); // On importe les routes des paniers depuis le fichier routes/cartRoutes.js. Ce fichier va contenir les routes pour la création, la mise à jour, la suppression et la récupération des paniers. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "cartRoutes.js". Dans ce fichier, on va définir les routes pour la création, la mise à jour, la suppression et la récupération des paniers. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const checkoutRoutes = require('./routes/checkoutRoutes'); // On importe les routes de paiement depuis le fichier routes/checkoutRoutes.js. Ce fichier va contenir les routes pour le paiement des commandes. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "checkoutRoutes.js". Dans ce fichier, on va définir les routes pour le paiement des commandes. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const orderRoutes = require('./routes/orderRoutes'); // On importe les routes des commandes depuis le fichier routes/orderRoutes.js. Ce fichier va contenir les routes pour la création, la mise à jour, la suppression et la récupération des commandes. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "orderRoutes.js". Dans ce fichier, on va définir les routes pour la création, la mise à jour, la suppression et la récupération des commandes. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const uploadRoutes = require('./routes/uploadRoutes'); // On importe les routes d'upload depuis le fichier routes/uploadRoutes.js. Ce fichier va contenir les routes pour l'upload des images des produits. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "uploadRoutes.js". Dans ce fichier, on va définir les routes pour l'upload des images des produits. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const subscribeRoute = require('./routes/subscribeRoute'); // On importe les routes des abonnements depuis le fichier routes/subscribeRoutes.js. Ce fichier va contenir les routes pour la gestion des abonnements. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "subscribeRoutes.js". Dans ce fichier, on va définir les routes pour la gestion des abonnements. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const adminRoutes = require('./routes/adminRoutes'); // On importe les routes d'administration depuis le fichier routes/adminRoutes.js. Ce fichier va contenir les routes pour la gestion des utilisateurs et des produits par l'administrateur. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "adminRoutes.js". Dans ce fichier, on va définir les routes pour la gestion des utilisateurs et des produits par l'administrateur. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const productAdminRoutes = require('./routes/productAdminRoutes'); // On importe les routes d'administration des produits depuis le fichier routes/productAdminRoutes.js. Ce fichier va contenir les routes pour la gestion des produits par l'administrateur. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "productAdminRoutes.js". Dans ce fichier, on va définir les routes pour la gestion des produits par l'administrateur. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const adminOrderRoutes = require('./routes/adminOrderRoutes'); // On importe les routes d'administration des commandes depuis le fichier routes/adminOrderRoutes.js. Ce fichier va contenir les routes pour la gestion des commandes par l'administrateur. On va créer ce fichier juste après avoir installé express et mongoose. On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "adminOrderRoutes.js". Dans ce fichier, on va définir les routes pour la gestion des commandes par l'administrateur. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
const app = express();                                                      // On initilise une application Express.
app.use(express.json());                                                    // On s'assure que notre serveur peut traiter les requêtes JSON.
app.use(cors());                                                            // On utilise CORS pour permettre les requêtes cross-origin. On va permettre à notre frontend de communiquer avec notre backend. Ainsi par exemple, si notre frontend est sur http://localhost:3000 et notre backend sur http://localhost:5000, on doit configurer CORS pour autoriser les requêtes entre ces deux domaines.

dotenv.config();                                                            // On charge les variables d'environnement à partir du fichier .env. 

const PORT = process.env.PORT || 3000;                                      // On définit le port sur lequel notre serveur va écouter les requêtes. Au lieu de hardcoder le port, on peut aussi utiliser une variable d'environnement pour le rendre plus flexible. Par exemple, on peut utiliser process.env.PORT || 9000. Le terme Hardcoder signifie que le port est codé en dur dans le code, ce qui n'est pas idéal pour la flexibilité et la portabilité de l'application. Soit on utilise une variable d'environnement pour définir le port, soit on hardcode le port directement dans le code. Ici, on utilise process.env.PORT pour récupérer la variable d'environnement PORT définie dans le fichier .env. Si cette variable n'est pas définie, on utilise 3000 comme valeur par défaut.

// On importe la fonction connectDB depuis le fichier config/db.js et on l'appelle pour se connecter à la base de données MongoDB.
connectDB();                                                     // On appelle la fonction connectDB pour se connecter à la base de données MongoDB. Cette fonction va contenir la logique de connexion à la base de données. On va créer ce fichier juste après avoir installé mongoose.

app.get('/', (req, res) => {
  res.send('WELCOME TO TREIDEN WEBSITE API!');                              // On définit une route de base qui renvoie "WELCOME TO TREIDEN !".
});

// Ajout des routes pour les utilisateurs définies dans le fichier userRoutes.js.
app.use('/api/users', userRoutes);                                         // Grace à cette ligne, on va pouvoir accéder aux routes définies dans le fichier userRoutes.js. Par exemple, si on a défini une route "POST /register" dans le fichier userRoutes.js (cf ligne 12 du fichier en question), on pourra y accéder via http://localhost:3000/api/users/register. On va aussi ajouter d'autres routes pour les utilisateurs dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use('/api/products', productRoutes);                                   // On ajoute les routes pour les produits définies dans le fichier productRoutes.js. Par exemple, si on a défini une route "POST /api/products" dans le fichier productRoutes.js, on pourra y accéder via http://localhost:3000/api/products. On va aussi ajouter d'autres routes pour les produits dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use('/api/cart', cartRoutes);                                         // On ajoute les routes pour les paniers définies dans le fichier cartRoutes.js. Par exemple, si on a défini une route "POST /api/carts" dans le fichier cartRoutes.js, on pourra y accéder via http://localhost:3000/api/carts. On va aussi ajouter d'autres routes pour les paniers dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use('/api/checkout', checkoutRoutes);                               // On ajoute les routes pour le paiement définies dans le fichier checkoutRoutes.js. Par exemple, si on a défini une route "POST /api/checkout" dans le fichier checkoutRoutes.js, on pourra y accéder via http://localhost:3000/api/checkout. On va aussi ajouter d'autres routes pour le paiement dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use('/api/orders', orderRoutes);                                       // On ajoute les routes pour les commandes définies dans le fichier orderRoutes.js. Par exemple, si on a défini une route "POST /api/orders" dans le fichier orderRoutes.js, on pourra y accéder via http://localhost:3000/api/orders. On va aussi ajouter d'autres routes pour les commandes dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use('/api/upload', uploadRoutes);                                       // On ajoute les routes pour l'upload d'images définies dans le fichier uploadRoutes.js. Par exemple, si on a défini une route "POST /api/upload" dans le fichier uploadRoutes.js, on pourra y accéder via http://localhost:3000/api/upload. On va aussi ajouter d'autres routes pour l'upload d'images dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use('/api', subscribeRoute);                                   // On ajoute les routes pour les abonnements définies dans le fichier subscribeRoutes.js. Par exemple, si on a défini une route "POST /api/subscribe" dans le fichier subscribeRoutes.js, on pourra y accéder via http://localhost:3000/api/subscribe. On va aussi ajouter d'autres routes pour les abonnements dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
                                                                        
// Admin
app.use("/api/admin/users", adminRoutes);                                       // On ajoute les routes pour l'administration définies dans le fichier adminRoutes.js. Par exemple, si on a défini une route "POST /api/admin/users" dans le fichier adminRoutes.js, on pourra y accéder via http://localhost:3000/api/admin/users. On va aussi ajouter d'autres routes pour l'administration dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use("/api/admin/products", productAdminRoutes); // On ajoute les routes pour l'administration des produits définies dans le fichier productAdminRoutes.js. Par exemple, si on a défini une route "POST /api/admin/products" dans le fichier productAdminRoutes.js, on pourra y accéder via http://localhost:3000/api/admin/products. On va aussi ajouter d'autres routes pour l'administration des produits dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.use("/api/admin/orders", adminOrderRoutes); // On ajoute les routes pour l'administration des commandes définies dans le fichier adminOrderRoutes.js. Par exemple, si on a défini une route "POST /api/admin/orders" dans le fichier adminOrderRoutes.js, on pourra y accéder via http://localhost:3000/api/admin/orders. On va aussi ajouter d'autres routes pour l'administration des commandes dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);             // On démarre le serveur et on affiche un message dans la console. On écoute les requêtes sur le port défini.
}); 
// On se rend ensuite sur le package.json et on ajoute un script "start" pour démarrer notre serveur. 
// On peut le faire en ajoutant la ligne suivante : "start": "node server.js" ou "node backend/server.js". Ainsi, on pourra démarrer notre serveur en utilisant la commande npm start dans le terminal. 
// Etant donné qu'on a crée un fichier "server.js". Notre fichier d'entrée principale sera server.js. Donc dans la partie "main" du package.json, on va mettre "server.js". 
// Au passage on peut aussi supprimer la ligne "test": "echo \"Error: no test specified\" 
// Juste en dessous de start on peut ajouter un script "dev" pour démarrer notre serveur en mode développement et en y ajoutant la librarie de nodemon. On peut le faire en ajoutant la ligne suivante : "dev": "nodemon server.js" ou "nodemon backend/server.js". Ainsi, on pourra démarrer notre serveur en mode développement en utilisant la commande npm run dev dans le terminal.On s'assure de spécifier correctement le chemin vers notre fichier "server.js" en mettant "nodemon backend/server.js". Le mode développement va nous permettre de redémarrer automatiquement le serveur à chaque fois qu'on fait une modification dans le code. On n'aura pas besoin de redémarrer manuellement le serveur à chaque fois qu'on fait une modification dans le code.
// Pour la gestion de la database on utilisera MongoDB.
// Dans l'url de mongodb qui nous est donné juste après "mongodb.net/" on peut ajouter le nom de notre base de données à la fin de l'url. Par exemple, si on veut appeler notre base de données "treiden", on peut mettre "mongodb.net/treiden" à la fin de l'url. MongoDb va alors créer une base de données du nom de "treiden" si elle n'existe pas déjà. 
// Quand on a fini de configuer la connexion a MongoDB on va maintenant s'occuper a la connexion (regsiter, login)des utilisateurs. On va configuer le User Shchema c'est à dire le modèle de données pour les utilisateurs. On va créer un dossier "models" dans le dossier "backend" et y créer un fichier "User.js". Dans ce fichier, on va définir le schéma de données pour les utilisateurs. On va utiliser mongoose pour définir le schéma de données. On va définir les champs suivants : username, email, password, isAdmin, createdAt, updatedAt. On va aussi ajouter des validations pour les champs email et password. On va aussi ajouter des méthodes pour hasher le mot de passe et vérifier le mot de passe. 
// On va aussi créer un dossier "routes" dans le dossier "backend" et y créer un fichier "userRoutes.js". Dans ce fichier, on va définir les routes pour l'inscription et la connexion des utilisateurs. Par exemple, on va définir une route POST "/api/users/register" pour l'inscription des utilisateurs et une route POST "/api/users/login" pour la connexion des utilisateurs. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
// On retourne dans le fichier "server.js" pour ajouter les routes des utilisateurs. On va utiliser la méthode app.use() pour ajouter les routes des utilisateurs. C'est-à-dire qu'on va ajouter les routes définies dans le fichier "userRoutes.js" à notre application Express. De tel sorte que si on a défini une route POST "/api/users/register" dans le fichier "userRoutes.js", on pourra y accéder via http://localhost:3000/api/users/register. On va aussi ajouter d'autres routes pour les utilisateurs dans ce fichier si nécessaire. On peut aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. On va aussi ajouter des middlewares pour gérer les erreurs et les réponses JSON.
// Pour faire les requetes (de simples tests ?) on va utiliser Postman. On va installer Postman sur notre ordinateur qui est un outil destiné à tester les API. Dans le but de tester l'api cet outil peut nous permettre d'envoyer des requêtes HTTP à notre serveur et tester les endpoints (les endpoints sont par exemple : "./register") . On va aussi utiliser Postman pour tester les routes que nous avons définies dans le fichier "userRoutes.js". 
// Alors que le Postman valide notre API après test (et dont les données entrées dans mongoDb peuvent etres retrouvés au sein du site) On retourne dans le fichier userRoutes.js et on va congigurer le token JWT pour sécuriser les routes. On va utiliser jsonwebtoken pour générer et vérifier les tokens JWT. 
// A la ligne 100 du fichier userRoutes.js "router.get("/profile", protect, async (req, res) =>" Le "protect" est un middleware qui est utilisé pour protéger la requete d'affichahge du profil de l'utilisateur. On va donc aussi créer un dossier "middleware" dans le dossier "backend" et y créer un fichier "authMiddleware.js". Dans ce fichier, on va définir les middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. 
// On a fini pour la conexion et le regsitration maintenant on passe à l'implémentation d'articles !

// Dans le dossier models on va créer un fichier "Product.js" pour définir le schéma de données pour les produits. On va utiliser mongoose pour définir le schéma de données. On va définir les champs suivants : name, description, price, image, category, stock, createdAt, updatedAt. On va aussi ajouter des validations pour les champs name, description et price.
// Puis on va créer au sein du dossier routes un fichier "productRoutes.js" pour définir les routes pour les produits. On va définir une route GET "/api/products" pour récupérer tous les produits et une route POST "/api/products" pour créer un nouveau produit Puis une route PUT et DELETE pour modifier et supprimer des produits. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin. 
// Quand on a fini de configurer les routes des produits, on se penche désormais sur l'affichage des produits sur le site. Avant de pouvoir les afficher on va ouvrir le dossier "pp2-treiden-assets" qui contient le dossier data-treiden lui-meme contenant le fichier products.js qui contient les données des produits JUSTE LA POUR ETRE TESTEE (c'est pourquoi leur images sont des picsums) avant qu'on puisse mettre les vrais produits.
// Pour alimenter la base de données avec les produits stockés dans le fichier products.js, on a besoin d'avoir un scirpt, on crée donc un nouveau fichier au sein du dossier backend du nom de "seeder.js". Dans ce fichier, on va  écrire un script pour alimenter la base de données avec les produits. On va utiliser mongoose pour se connecter à la base de données et insérer les produits dans la collection "products". On va aussi créer un utilisateur administrateur par défaut pour pouvoir gérer les produits. etc.
// Une fois que c'est fait on passe a la gestion du panier. On va implementer la particularité qui permet de mélanger l'ajout au panier fait par un invité avec son nouveau compte créé une fois qu'il se sera connecté ou aura créer un compte. On va y arriver par le MERGE de la route. Donc guest user cart CONVERTED TO registered user cart.
// On a le champ "user" qui va stocker l'information de l'utilisateur connecté qui a ajouté qqch dans le panier. ON aura aussi un champ pour stocker l'id de l'utilisateur invité dans le cas ou celui-ci n'est pas encore connecté. Puis on a un champs "products"  qui sera un tableau d'objets contenant les informations des produits ajoutés au panier par l'utilisateur. Les objects du paniers ressemblent à ça : ProductId : "productId" (objectId), name: "Product Name" (string), image: "imageUrl" (string) , price: 100 (string), size: "M"(string), color: "Red"(string), quantity: 1 (number), 
// On passe a la partie paiement/caisse (chekout). On va créer les routes pour le paiement/la caisse dans un fichier type : "checkoutRoutes.js" . Un route sera pour créer session de paiement/ de la caisse, puis une autre pour vérifier le statut du paiement / statut de la caisse et le dernier sera pour finaliser le paiement/valider la caisse ?) et la convertir en commande (order)  On va créer aussi un chekoutItem Schema on créera aussi un orderitemschema qui rassemble toute la commande (voir explication youtb 10:14:30)
// On a fini le checkout et le order. On crée maintenant un nouveau fichier au sein du dossier routes order Routes qu'on remplit.  On a terminé le order routes !

// Maintenant on va aussi implementer une focntionnalité pour uploader une image aux produits concerncés tout cela à partir la session administrateur. Pour cela nous allons utiliser l'API de cloudinary 
// Pour ce faire on installe le package multer cloudinary streamifier. Multer est utilisé pour gérer les fichiers téléchargés (file uploads) dans les requêtes HTTP. Il permet de traiter les fichiers envoyés par le client, de les stocker temporairement et de les rendre accessibles dans l'application. le package cloudinary est utilisé pour interagir et communiquer avec l'API de Cloudinary, et streamifier est utilisé pour convertir les fichiers téléchargés en flux (streams) afin de les envoyer à Cloudinary. Cloudinary est un service de gestion d'images et de vidéos dans le cloud qui permet de stocker, de transformer et de diffuser des médias. En utilisant Cloudinary, on peut facilement gérer les images et les vidéos dans notre application sans avoir à se soucier de l'hébergement et du traitement des médias.
// Fini, on passe maintenant a la partie subscribe. On crée d'abord un fichier Subscribe.js dans le dossier models. On va y définir le schéma de données pour les abonnements. On va utiliser mongoose pour définir le schéma de données. Puis on va créer un fichier "subscribeRoutes.js" dans le dossier routes pour définir les routes pour les abonnements. On va définir une route POST "/api/subscribe" pour créer un nouvel abonnement.
// Fini, on passe maintennat a la partie gestion des Utilisateur (users). ON veut pouvoir créer des utilisateurs, les modifier, les supprimer etc.
// Order management maintenant ! Dans le dossier routes on crée un fichier "adminOderRoutes.js" pour définir les routes pour la gestion des commandes par l'administrateur.  Au sein du fichier on peut par exemple définir une route GET "/api/admin/orders" pour récupérer toutes les commandes et une route PUT "/api/admin/orders/:id" pour mettre à jour le statut d'une commande. On va aussi ajouter des middlewares pour vérifier si l'utilisateur est connecté et s'il est admin.
// LE BACKEND EST TERMINÉ ! 
